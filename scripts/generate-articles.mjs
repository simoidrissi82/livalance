// Build-time script: generates edge-safe article data modules
// - Extracts frontmatter and raw MDX body from content/<locale>/**/*.mdx
// - Writes src/generated/articles-data.ts with two exports:
//     articlesFrontmatters: Record<locale, Array<FrontmatterJson>>
//     articlesSources: Record<locale, Record<slug, string>>
// This avoids using `fs` at runtime on Cloudflare Edge.

import {promises as fs} from 'node:fs';
import path from 'node:path';
import {fileURLToPath} from 'node:url';
import {compileMDX} from 'next-mdx-remote/rsc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, '..');
const contentRoot = path.join(repoRoot, 'content');
const outDir = path.join(repoRoot, 'src', 'generated');
const outFile = path.join(outDir, 'articles-data.ts');

/**
 * Very small frontmatter stripper for `---` delimited blocks at start of file.
 * Returns { body, hasFrontmatter } and does not parse the YAML content itself.
 */
function stripFrontmatter(source) {
  if (!source.startsWith('---')) return {body: source, hasFrontmatter: false};
  const end = source.indexOf('\n---', 3);
  if (end === -1) return {body: source, hasFrontmatter: false};
  const after = source.indexOf('\n', end + 4);
  const body = after === -1 ? '' : source.slice(after + 1);
  return {body, hasFrontmatter: true};
}

async function readFile(filePath) {
  return fs.readFile(filePath, 'utf-8');
}

async function* walkMdxFiles(dir) {
  const entries = await fs.readdir(dir, {withFileTypes: true});
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      yield* walkMdxFiles(full);
    } else if (entry.isFile() && entry.name.endsWith('.mdx')) {
      yield full;
    }
  }
}

async function collectArticles() {
  const localeEntries = await fs.readdir(contentRoot, {withFileTypes: true});
  const localesFiltered = localeEntries
    .filter((e) => e.isDirectory())
    .map((e) => e.name)
    .filter((l) => !l.startsWith('.'));

  /** @type {Record<string, Array<any>>} */
  const frontmatters = {};
  /** @type {Record<string, Record<string, string>>} */
  const sources = {};

  for (const locale of localesFiltered) {
    const localeDir = path.join(contentRoot, locale);
    frontmatters[locale] = [];
    sources[locale] = {};

    for await (const filePath of walkMdxFiles(localeDir)) {
      const source = await readFile(filePath);

      // Use compileMDX only to parse frontmatter (fast path, no components)
      const {frontmatter} = await compileMDX({
        source,
        options: {parseFrontmatter: true}
      });

      if (!frontmatter || !frontmatter.slug) {
        // Skip files without the expected metadata
        continue;
      }

      // Keep the raw MDX body (without frontmatter) for runtime compilation on Edge
      const {body} = stripFrontmatter(source);
      sources[locale][frontmatter.slug] = body;

      // Store JSON-serializable frontmatter; keep publishDate as ISO string
      const fm = {
        ...frontmatter,
        locale,
        publishDate: String(frontmatter.publishDate)
      };
      frontmatters[locale].push(fm);
    }

    // Stable sort by publishDate desc (string sort works for ISO dates)
    frontmatters[locale].sort((a, b) => (a.publishDate < b.publishDate ? 1 : -1));
  }

  return {frontmatters, sources};
}

function escapeForTsString(str) {
  return str
    .replaceAll('\\', '\\\\')
    .replaceAll('`', '\\`')
    .replaceAll('\u2028', '\\u2028')
    .replaceAll('\u2029', '\\u2029');
}

async function writeOutput(frontmatters, sources) {
  await fs.mkdir(outDir, {recursive: true});

  // Serialize objects as TS code. MDX bodies are embedded as template literals.
  const locales = Object.keys(frontmatters);

  const fmEntries = locales
    .map((loc) => {
      const arr = frontmatters[loc]
        .map((fm) => {
          // Publish date stays as ISO string; transform to Date in consumer
          const {publishDate, ...rest} = fm;
          const json = JSON.stringify(rest, null, 0);
          return `({ ...${json}, publishDate: '${publishDate}' })`;
        })
        .join(',');
      return `${JSON.stringify(loc)}: [${arr}]`;
    })
    .join(',');

  const srcEntries = locales
    .map((loc) => {
      const inner = Object.entries(sources[loc])
        .map(([slug, body]) => `${JSON.stringify(slug)}: \
` +
          '`' + escapeForTsString(body) + '`')
        .join(',');
      return `${JSON.stringify(loc)}: {${inner}}`;
    })
    .join(',');

  const code = `// Auto-generated by scripts/generate-articles.mjs â€” do not edit.
// Frontmatters have ISO publishDate; consumers should convert to Date.
export const articlesFrontmatters = {${fmEntries}} as const;
export const articlesSources = {${srcEntries}} as const;
`;

  await fs.writeFile(outFile, code, 'utf-8');
}

try {
  const {frontmatters, sources} = await collectArticles();
  await writeOutput(frontmatters, sources);
  // eslint-disable-next-line no-console
  console.log(`Generated ${path.relative(repoRoot, outFile)}`);
} catch (err) {
  // eslint-disable-next-line no-console
  console.error('Failed to generate articles data:', err);
  process.exit(1);
}
